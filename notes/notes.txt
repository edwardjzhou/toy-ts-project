https://en.wikipedia.org/wiki/Record_(computer_science)
// syntax of my files
the abstract idea of "DATA" is what I call a RECORD 
the RECORD in JS form is an OBJECT like { ...column keys(fields): record values, ...custom keys: derived values/joins } 
    *  ex: new Course() and it may have a course.tests custom key
the RECORD in SQL form is a ROW in a TABLE



// DB side:
// TABLE has ROWS of RECORDS

// CSV side: 
// .csv file has /n separated STRINGS of RECORDS

// on CODE side:
// MODEL (for each table)
// connects a db's TABLE to JS
// SHOULD ACTIVELY SANITIZE A RECORD, TYPE A RECORD, AND ADD CUSTOM COLUMNS OR OTHER SQL ops; BUT PERFORM NO OTHER LOGIC
// it also creates the join table relations with has_many belongs_to
// other viewpoint is that the TREND is to have fat models with more custom methods? skinny controllers
// activeRecord is abstraction for migrating (insert update set)

// SCHEMA is all tables FROM a db; or all models post object-ifying them? or during migration?
// SCHEMA = course schema + mark schema + ... 

// CONTROLLER 
// wrangles things for the view by having all the methods like class User {index () => User.all} 
or in our case prepares everything for the JSON view


https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch



using function f(){}
(0, f)(params) to lose context of this intentionally
remember to use void 0 void iifes

conditional spreads
function copyOwner(pet?: Animal) {
    return {
        ...(pet?.owner),
        otherStuff: 123
    }
}

generics in constraints T extends string, U extends keyof T etc can constrain EACH OTHER
can also providd def arg like type asdf<T = string> = T exte...
as const arrays to tuples 

X extends Y means (Y is assignable to X) but not necesarily othe rway around



type asdf <T>{
    [P in keyof T]: T[P] extends {231:23} ? never : T[P]
}[keyof T]

to get keys after mapping; removes any nevered out ones in conditional mappings


function removeProp(dog: Dog): Omit<Dog, 'age'> { 
 const newDog = { ...dog } as Partial<Dog>; 
 delete newDog.age; 
 return newDog as Omit<Dog,'age'>; 
} 
 
type Dog = { 
 age: number; 
 color: string; 
 name: string; 
} 


OBJEC LITERAL TYPES like ad-hoc ones CANNOT have more props than written
like you cant {
    name: 'df'
    id:1 
}
function logName(something: { name: string }) {
    console.log(something.name);
}
